var documenterSearchIndex = {"docs":
[{"location":"tips/#tips-1","page":"Tips","title":"Tips","text":"","category":"section"},{"location":"tips/#","page":"Tips","title":"Tips","text":"This page of the documentation holds miscellaneous tips for using the package.","category":"page"},{"location":"tips/#Writing-functions-compatible-with-automatic-differentiation-1","page":"Tips","title":"Writing functions compatible with automatic differentiation","text":"","category":"section"},{"location":"tips/#","page":"Tips","title":"Tips","text":"Use an in-place function to avoid type errors.\nFor example, define the ccgf as ccgf(F, x). You can use the element type of F via eltype(F) to ensure that you don't get a type error from using Float64 instead of Dual inside the function. If ccgf was out-of-place, then depending on how the vector being returned is coded, you may get a type error if elements of the return vector are zero or constant numbers. By having F available, you can guarantee these numbers can be converted to Dual types if needed without always declaring them as Dual types.","category":"page"},{"location":"tips/#","page":"Tips","title":"Tips","text":"Use dualvector or dualarray.\nThe package provides these two helper functions in the case where you have a function f(x, y), and you need to be able to automatcally differentiate with respect to x and y separately. For example, the nonlinear terms of the expectational equation ξ(z, y) takes this form. Within , you can pre-allocate the return vector by calling F = RiskAdjustedLinearizations.dualvector(z, y). The dualvector function will infer from z and y whether F should be have Dual element types or not so you can repeatedly avoid writing if-else conditional blocks. The dualarray function generalizes this to arbitrary AbstractMatrix inputs. See the out-of-place function for ξ in examples/wachter_disaster_risk/wachter.jl.","category":"page"},{"location":"tips/#","page":"Tips","title":"Tips","text":"Don't pre-allocate the return vector.\nInstead of pre-allocating the return vector at the  top of the function for an out-of-place function, just concatenate the individual elements  at the very end. Julia will figure out the appropriate element type for you. The downside of this  approach is that you won't be able to assign names to the specific indices of the return vector (e.g.  does this equation define the risk-free interest rate?). For small models, this disadvantage is generally not a problem.  See the definition of the out-of-place expected state transition function μ in examples/wachter_disaster_risk/wachter.jl.","category":"page"},{"location":"risk_adjusted_linearization/#risk-adjusted-linearization-1","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"","category":"section"},{"location":"risk_adjusted_linearization/#Theory-1","page":"Risk-Adjusted Linearizations","title":"Theory","text":"","category":"section"},{"location":"risk_adjusted_linearization/#Nonlinear-Model-1","page":"Risk-Adjusted Linearizations","title":"Nonlinear Model","text":"","category":"section"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"Most dynamic economic models can be formulated as the system of nonlinear equations","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"beginaligned\n    z_t + 1  = mu(z_t y_t) + Lambda(z_t)(y_t + 1 - mathbbE_t y_t + 1) + Sigma(z_t) varepsilon_t + 1\n    0  = logmathbbE_texp(xi(z_t y_t) + Gamma_5 z_t + 1 + Gamma_6 y_t + 1)\nendaligned","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"The vectors z_tin mathbbR^n_z and y_t in mathbbR^n_y are the state and jump variables, respectively. The first vector equation comprise the model's expectational equations, which are typically the first-order conditions for the jump variables from agents' optimization problem. The second vector equation comprise the transition equations of the state variables. The exogenous shocks varepsiloninmathbbR^n_varepsilon form a martingale difference sequence whose distribution is described by the differentiable, conditional cumulant generating function (ccgf)","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"beginaligned\nkappaalpha(z_t) mid z_t = logmathbbE_texp(alpha(z_t) varepsilon_t + 1)quad text for any differentiable map alphamathbbR^n_zrightarrowmathbbR^n_varepsilon\nendaligned","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"The functions","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"beginaligned\nximathbbR^2n_y + 2n_zrightarrow mathbbR^n_y quad mumathbbR^n_y + n_zrightarrow mathbbR^n_z\nLambdamathbbR^n_z rightarrow mathbbR^n_z times n_y  quad SigmamathbbR^n_z rightarrow mathbbR^n_ztimes n_varepsilon\nendaligned","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"are differentiable. The first two functions characterize the effects of time t variables on the expectational and state transition equations. The function Lambda characterizes heteroskedastic endogenous risk that depends on innovations in jump variables while the function Sigma characterizes exogenous risk.","category":"page"},{"location":"risk_adjusted_linearization/#Risk-Adjusted-Linearizations-by-Affine-Approximation-1","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations by Affine Approximation","text":"","category":"section"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"Many economic models are typically solved by perturbation around the deterministic steady state. To break certainty equivalence so that asset pricing is meaningful, these perturbations need to be at least third order. However, even third-order perturbations can poorly approximate the true global solution. A key problem is that the economy may not spend much time near the deterministic steady state, so a perturbation around this point will be inaccurate.","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"Instead of perturbing the model's nonlinear equations around the deterministic steady state, we could perturb around the stochastic or \"risky\" steady state. This point is better for a perturbation because the economy will spend a large amount of time near the stochastic steady state. Lopez et al. (2018) show that an affine approximation of the model's nonlinear equation is equivalent to a linearization around the stochastic steady state. Further, they confirm that in practice this \"risk-adjusted\" linearization approximates global solutions of canonical economic models very well and outperforms perturbations around the deterministic steady state.","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"The affine approximation of an dynamic economic model is","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"beginaligned\n    mathbbEz_t + 1  = mu(z y) + Gamma_1(z_t - z) + Gamma_2(y_t - y)\n    0                       = xi(z y) + Gamma_3(z_t - z) + Gamma_4(y_t - y) + Gamma_5 mathbbE_t z_t + 1 + Gamma_6 mathbbE_t y_t + 1 + mathcalV(z) + JmathcalV(z)(z_t  - z)\nendaligned","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"where Gamma_1 Gamma_2 are the Jacobians of mu with respect to z_t and y_t, respectively; Gamma_3 Gamma_4 are the Jacobians of xi with respect to z_t and y_t, respectively; Gamma_5 Gamma_6 are constant matrices; mathcalV(z) is the model's entropy; and JmathcalV(z) is the Jacobian of the entropy;","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"and the state variables z_t and jump variables y_t follow","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"beginaligned\n    z_t + 1  = z + Gamma_1(z_t - z) + Gamma_2(y_t - y) + (I_n_z - Lambda(z_t) Psi)^-1Sigma(z_t)varepsilon_t + 1\n    y_t        = y + Psi(z_t - z)\nendaligned","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"The unknowns (z y Psi) solve the system of equations","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"beginaligned\n0  = mu(z y) - z\n0  = xi(z y) + Gamma_5 z + Gamma_6 y + mathcalV(z)\n0  = Gamma_3 + Gamma_4 Psi + (Gamma_5 + Gamma_6 Psi)(Gamma_1 + Gamma_2 Psi) + JmathcalV(z)\nendaligned","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"Refer to Lopez et al. (2018) \"Risk-Adjusted Linearizations of Dynamic Equilibrium Models\" for more details about the theory justifying this approximation approach.","category":"page"},{"location":"risk_adjusted_linearization/#Implementation:-RiskAdjustedLinearization-1","page":"Risk-Adjusted Linearizations","title":"Implementation: RiskAdjustedLinearization","text":"","category":"section"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"We implement risk-adjusted linearizations of nonlinear dynamic economic models through the wrapper type RiskAdjustedLinearization. The user only needs to define the functions and matrices characterizing the equilibrium of the nonlinear model. Once these functions are defined, the user can create a RiskAdjustedLinearization object, which will automatically create the Jacobian functions needed to compute the affine approximation.","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"To ensure efficiency in speed and memory, this package takes advantage of a number of features that are easily accessible through Julia.","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"The Jacobians are calculated using forward-mode automatic differentiation rather than symbolic differentiation.\nThe Jacobian functions are constructed to be in-place with pre-allocated caches.\nFunctions provided by the user will be converted into in-place functions with pre-allocated caches.\n(Coming in the future) Calculation of Jacobians with automatic differentiation is accelereated by exploiting sparsity with SparseDiffTools.jl","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"See the Example for how to use the type.","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"@docs\nRiskAdjustedLinearizations.RiskAdjustedLinearization","category":"page"},{"location":"risk_adjusted_linearization/#Helper-Types-1","page":"Risk-Adjusted Linearizations","title":"Helper Types","text":"","category":"section"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"To organize the functions comprisng a risk-adjusted linearization, we create two helper types, RALNonlinearSystem and RALLinearizedSystem. The first type holds the mu, Lambda, Sigma, xi, and mathcalV functions while the second type holds the mu_z, mu_y, xi_z, xi_y, JmathcalV, Gamma_5, and Gamma_6 quantities. The RALNonlinearSystem type holds potentially nonlinear functions, and in particular mu, xi, and mathcalV, which need to be linearized (e.g. by automatic differentiation). The RALLinearizedSystem holds both matrices that are only relevant once the model is linearized, such as Gamma_1 (calculated by mu_z), as well as Gamma_5 and Gamma_6 since these latter two quantities are always constant matrices.","category":"page"},{"location":"risk_adjusted_linearization/#","page":"Risk-Adjusted Linearizations","title":"Risk-Adjusted Linearizations","text":"Aside from providing a way to organize the various functions comprising a risk-adjusted linearization, these helper types do not have much additional functionality. The update! functions for a RiskAdjustedLinearization, for example, are implemented underneath the hood by calling update! functions written for the RALNonlinearSystem and RALLinearizedSystem.","category":"page"},{"location":"caching/#caching-1","page":"Caching","title":"Caching","text":"","category":"section"},{"location":"caching/#","page":"Caching","title":"Caching","text":"If users create a RiskAdjustedLinearization with the constructor","category":"page"},{"location":"caching/#","page":"Caching","title":"Caching","text":"RiskAdjustedLinearization(μ, Λ, Σ, ξ, Γ₅, Γ₆, ccgf, z, y, Ψ, Nε)","category":"page"},{"location":"caching/#","page":"Caching","title":"Caching","text":"where μ, Λ, Σ, ξ, ccgf are either in-place or out-of-place functions, then we use the wrapper types RALF1 and RALF2 to convert these functions to non-allocating ones. The implementation of these wrappers is similar to the implementation of LinSolveFactorize in DifferentialEquations.jl. See Automated Caching via RALF1 and RALF2 for further details. Unlike LinSolveFactorize, however, we need to be able to automatically differentiate with RALF1 and RALF2 so the cache needs to be handled more carefully. To do this, we utilize and extend the DiffCache type implemented by DiffEqBase.jl.","category":"page"},{"location":"caching/#new-cache-types-1","page":"Caching","title":"TwoDiffCache and ThreeDiffCache","text":"","category":"section"},{"location":"caching/#","page":"Caching","title":"Caching","text":"The idea for DiffCache is that you need two caches, one for Dual numbers when applying automatic differentiation and one for the subtype of Number used for the actual array (e.g. Float64). For the Lambda and Sigma functions, this type works because they are functions of one input variables. The functions mu_z, mu_y, xi_z, and xi_y also can use DiffCache once it is extended to work for functions with two input variables (e.g. the chunk size should depend on the length of both input variables).","category":"page"},{"location":"caching/#","page":"Caching","title":"Caching","text":"However, for the mu, xi, and mathcalV functions, we actually need multiple caches for Dual numbers that differ in their chunk size. The reason is that not only do we need to be able to evaluate them with Dual numbers but we also need to apply automatic differentiation to calculate their Jacobians. Because all three of these functions take two input variables, the chunk size for the cache used to evaluate the functions themselves will be different from the cache used to calculate the Jacobians, which occur with respect to only one of the input variables.","category":"page"},{"location":"caching/#ralf-wrappers-1","page":"Caching","title":"Automated Caching via RALF1 and RALF2 Wrappers","text":"","category":"section"},{"location":"caching/#","page":"Caching","title":"Caching","text":"The RALF1 type applies to functions with 1 input variables (Lambda and Sigma) and RALF2 to functions with 2 input variables (e.g. mu, mu_z). The way these wrappers work is that they take a user-defined function f and convert it to a new in-place function whose first input argument is a cache, which is a DiffCache, TwoDiffCache, or a ThreeDiffCache. The RALF1 and RALF2 types are callable in the same way LinSolveFactorize is.","category":"page"},{"location":"caching/#","page":"Caching","title":"Caching","text":"For RALF2, the syntax (x::RALF2)(x1, x2) on its own would not work, however, because (1) it is not clear which input should be used to infer whether or not to use a Dual cache and (2) there are potentially multiple Dual caches. To get around this problem, we add an optional third argument named select, which is a Tuple{Int, Int}. The first element specifies which input argument to use for infering whether a Dual cache is needed, and the second element specifies which cache to use. By default, select = (1, 1).","category":"page"},{"location":"#Home-1","page":"Home","title":"RiskAdjustedLinearizations.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package provides a user-friendly API for efficiently calculating risk-adjusted linearizations of dynamic economic models. These linearizations are equivalent to first-order perturbations around the stochastic steady state and are solved by computing affine approximations.","category":"page"},{"location":"#License-1","page":"Home","title":"License","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This content is released under the MIT License.","category":"page"},{"location":"#Contents-1","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"risk_adjusted_linearization.md\", \"numerical_algorithms.md\", \"example.md\", \"caching.md\", \"tips.md\"]","category":"page"},{"location":"numerical_algorithms/#numerical-algorithms-1","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"","category":"section"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"To calculate the risk-adjusted linearization, we need to solve a system of nonlinear equations. These equations are generally solvable using Newton-type methods. The package currently has two available algorithms, relaxation and homotopy continuation","category":"page"},{"location":"numerical_algorithms/#solve!-1","page":"Numerical Algorithms","title":"solve!","text":"","category":"section"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"The primary interface for calculating a risk-adjusted linearization once a RiskAdjustedLinearization object is created is the function solve!. The user selects the desired numerical algorithm through algorithm keyword of solve!.","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"All of the available algorithms need to solve a system of nonlinear equations. We use nlsolve for this purpose, and all keyword arguments for nlsolve can be passed as keyword arguments to solve!, e.g. autodiff and ftol.","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"RiskAdjustedLinearizations.solve!","category":"page"},{"location":"numerical_algorithms/#RiskAdjustedLinearizations.solve!","page":"Numerical Algorithms","title":"RiskAdjustedLinearizations.solve!","text":"solve!(m; algorithm = :relaxation, autodiff = :central, use_anderson = false, verbose = :high, kwargs...)\nsolve!(m, z0, y0; algorithm = :relaxation, autodiff = :central, use_anderson = false, verbose = :high, kwargs...)\nsolve!(m, z0, y0, Ψ0; algorithm = :relaxation, autodiff = :central, use_anderson = false, verbose = :high, kwargs...)\n\ncomputes the risk-adjusted linearization of the dynamic economic model described by m and updates m with the solution, e.g. the coefficients (z y Psi).\n\nThe three available solve! algorithms are slight variations on each other.\n\nMethod 1: uses the z, y, and Ψ fields of m as initial guesses   for (z y Psi) and proceeds with the numerical algorithm   specified by algorithm\nMethod 2: uses z0 and y0 as initial guesses for the deterministic   steady state, which is then used as the initial guess for (z Y Psi)   for the numerical algorithm specified by algorithm.\nMethod 3: uses z0, y0, and Ψ0 as initial guesses for (z Y Psi)   and proceeds with the numerical algorithm specified by algorithm.\n\nInputs\n\nm::RiskAdjustedLinearization: object holding functions needed to calculate   the risk-adjusted linearization\nz0::AbstractVector{S1}: initial guess for z\ny0::AbstractVector{S1}: initial guess for y\nΨ0::AbstractVector{S1}: initial guess for Psi\nS1 <: Real\n\nKeywords\n\nalgorithm::Symbol: speciifies which numerical algorithm to use. Can be one of [:relaxation, :homotopy, :deterministic].\nautodiff::Symbol: specifies whether to use autodiff. This is the keyword is the same as in nlsolve.\nuse_anderson::Bool: specifies whether to use Anderson acceleration if the relaxation algorithm is applied.\n\nThe solution algorithms all use nlsolve to calculate the solution to systems of nonlinear equations. The user can pass in any of the keyword arguments for nlsolve to adjust the settings of the nonlinear solver.\n\nFor the keywords relevant to specific methods, see the docstring for the underlying method being called. Note these methods are not exported.\n\n:relaxation -> relaxation!\n:homotopy -> homotopy!\n:deterministic -> deterministic_steadystate!\n\n\n\n\n\n","category":"function"},{"location":"numerical_algorithms/#relaxation-1","page":"Numerical Algorithms","title":"Relaxation","text":"","category":"section"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"The first and default numerical algorithm is a relaxation algorithm. The key problem in solving the equations characterizing (z y Psi) is that it is difficult to jointly solve the nonlinear matrix equation for Psi along with the steady-state equations for z and y due to the presence of the entropy term. The relaxation algorithm splits the solution of these equations into two steps, which allows us to calculate guesses of Psi using linear algebra. It is in this sense that this iterative algorithm is a relaxation algorithm.","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"The system of equations characterizing the coefficients (z y Psi) are solved iteratively in two separate steps. Given previous guesses (z_n - 1 y_n - 1 Psi_n - 1), we calculate (z_n y_n) such that","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"beginaligned\n0  = mu(z_n y_n) - z_n\n0  = xi(z_n y_n) + Gamma_5 z_n + Gamma_6 y_n + mathcalV(z_n - 1)\nendaligned","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"is satisfied. In other words, we hold the entropy term constant and update (z_n y_n) in the remaining terms. The coefficients are solved efficiently through nlsolve with (z_n - 1 y_n - 1) as initial guesses.","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"Then we compute Psi_n by solving","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"beginaligned\n0  = Gamma_3 + Gamma_4 Psi_n + (Gamma_5 + Gamma_6 Psi_n)(Gamma_1 + Gamma_2 Psi_n) + JmathcalV(z_n - 1)\nendaligned","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"with a Generalized Schur decomposition (also known as QZ decomposition). Notice that we also hold the Jacobian of the entropy constant. Only after we have a new round of (z_n y_n Psi_n) do we update the entropy-related terms.","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"Convergence is achieved once (z_n y_n Psi_n) are sufficiently close under some norm. By default, we use the L^infty norm (maximum absolute error).","category":"page"},{"location":"numerical_algorithms/#homotopy-1","page":"Numerical Algorithms","title":"Homotopy Continuation","text":"","category":"section"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"When the deterministic steady state exists, it is typically an easy problem to solve numerically. We can therefore use the equations characterizing the deterministic steady state for a homotopy continuation method. Let q be the embedding parameter. Then the homotopy continuation method iteratively solves","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"beginaligned\n0  = mu(z y) - z\n0  = xi(z y) + Gamma_5 z + Gamma_6 y + q mathcalV(z)\n0  = Gamma_3 + Gamma_4 Psi + (Gamma_5 + Gamma_6 Psi)(Gamma_1 + Gamma_2 Psi) + q JmathcalV(z)\nendaligned","category":"page"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"for the coefficients (z_q y_q Psi_q) by increasing q from 0 to 1.","category":"page"},{"location":"numerical_algorithms/#blanchard-kahn-1","page":"Numerical Algorithms","title":"Blanchard-Kahn Conditions","text":"","category":"section"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"At the end of solve!, we check the stochastic steady state found is locally unique and saddle-path stable by checking what are known as the Blanchard-Kahn conditions. Standard references for computational macroeconomics explain what these conditions are, so we defer to them (e.g. Blanchard-Kahn (1980), Klein (2000), and Sims (2002)). For the stochastic steady state, these conditions are essentially identical to the conditions for the deterministic steady state, but the Jacobian of the expectational equations to z_t also includes the Jacobian of the entropy. In the deterministic steady state, the entropy is zero, hence the Jacobian of the entropy is zero. In the stochastic steady state, the entropy is no longer zero and varies with z_t, hence the Jacobian of the expectational equations to z_t depends on entropy.","category":"page"},{"location":"numerical_algorithms/#Docstrings-1","page":"Numerical Algorithms","title":"Docstrings","text":"","category":"section"},{"location":"numerical_algorithms/#","page":"Numerical Algorithms","title":"Numerical Algorithms","text":"RiskAdjustedLinearizations.relaxation!\nRiskAdjustedLinearizations.homotopy!\nRiskAdjustedLinearizations.blanchard_kahn","category":"page"},{"location":"numerical_algorithms/#RiskAdjustedLinearizations.relaxation!","page":"Numerical Algorithms","title":"RiskAdjustedLinearizations.relaxation!","text":"relaxation!(ral, xₙ₋₁, Ψₙ₋₁; tol = 1e-10, max_iters = 1000, damping = .5, pnorm = Inf,\n            schur_fnct = schur!, autodiff = :central, use_anderson = false, m = 5,\n            verbose = :none, kwargs...)\n\nsolves for the coefficients (z y Psi) of a risk-adjusted linearization by the following relaxation algorithm:\n\nInitialize guesses for (z y Psi)\nDo until convergence\na) Solve for (z y) using the expectational and state transition equations and fixing Psi.\nb) Use a QZ decomposition to solve for Psi while fixing (z y).\n\nTypes:\n\nS1 <: Number\nS2 <: Real\nS3 <: Real\n\nInputs\n\nm::RiskAdjustedLinearization: object holding functions needed to calculate   the risk-adjusted linearization\nxₙ₋₁::AbstractVector{S1}: initial guess for (z y)\nΨₙ₋₁::AbstractVector{S1}: initial guess for Psi\n\nKeywords\n\ntol::S2: convergence tolerance of residual norm for relaxation algorithm\nmax_iters::Int: maximumm number of iterations\ndamping::S2: guesses are updated as the weighted average   xₙ = damping * proposal + (1 - damping) * xₙ₋₁.\npnorm::S3: norm for residual tolerance\nschur_fnct::Function: function for calculating the Schur factorization during QZ decomposition\nautodiff::Symbol: specifies whether to use autoamtic differentiation in nlsolve   (and is the same keyword as the autodiff keyword for nlsolve)\nuse_anderson::Bool: set to true to apply Anderson acceleration to the   fixed point iteration of the relaxation algorithm\nm::Int: m coefficient if using Anderson acceleration\nverbose::Symbol: verbosity of information printed out during solution.   a) :low -> statement when homotopy continuation succeeds   b) :high -> statement when homotopy continuation succeeds and for each successful iteration\n\n\n\n\n\n","category":"function"},{"location":"numerical_algorithms/#RiskAdjustedLinearizations.homotopy!","page":"Numerical Algorithms","title":"RiskAdjustedLinearizations.homotopy!","text":"homotopy!(m, xₙ₋₁; step = .1, verbose = :none, kwargs...)\n\nsolves the system of equations characterizing a risk-adjusted linearization by a homotopy method with embedding parameter q, which steps from 0 to 1, with q = 1 obtaining the true solution.\n\nCurrently, the only algorithm for choosing q is a simple uniform step search. Given a step size Delta, we solve the homotopy starting from q = Delta and increase q by Delta until q reaches 1 or passes 1 (in which case, we force q = 1).\n\nTypes:\n\nS1 <: Number\n\nInputs\n\nm::RiskAdjustedLinearization: object holding functions needed to calculate   the risk-adjusted linearization\nxₙ₋₁::AbstractVector{S1}: initial guess for (z y Psi)\n\nKeywords\n\nstep::Float64: size of the uniform step from step to 1.\nverbose::Symbol: verbosity of information printed out during solution.   a) :low -> statement when homotopy continuation succeeds   b) :high -> statement when homotopy continuation succeeds and for each successful iteration\n\n\n\n\n\n","category":"function"},{"location":"numerical_algorithms/#RiskAdjustedLinearizations.blanchard_kahn","page":"Numerical Algorithms","title":"RiskAdjustedLinearizations.blanchard_kahn","text":"blanchard_kahn(m::RiskAdjustedLinearization; deterministic::Bool = false, verbose::Symbol = :high)\n\nchecks the Blanchard-Kahn conditions for whether a first-order perturbation is saddle-path stable or not.\n\nIf verbose is :low or :high, a print statement will be shown if the Blanchard-Kahn conditions are satisfied.\n\n\n\n\n\n","category":"function"},{"location":"example/#example-1","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"This example shows how to calculate the risk-adjusted linearization of the discrete-time version of the Wachter (2013) model with disaster-risk. You can run this example using the script examples/wachter_disaster_risk/example_wachter.jl. For the equivalent code in MATLAB provided by Lopez et al., see here.","category":"page"},{"location":"example/#Create-a-RiskAdjustedLinearization-1","page":"Example","title":"Create a RiskAdjustedLinearization","text":"","category":"section"},{"location":"example/#Define-Nonlinear-System-1","page":"Example","title":"Define Nonlinear System","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The user generally needs to define","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"mu: expected state transition function\nxi nonlinear terms of the expectational equations\nccgf: conditional cumulant generating function of the exogenous shocks\nLambda: function or matrix mapping endogenous risk into state transition equations\nSigma: function or matrix mapping exogenous risk into state transition equations\nGamma_5: coefficient matrix on one-period ahead expectation of state variables\nGamma_6: coefficient matrix on one-period ahead expectation of jump variables","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"The quantities mu, xi, and ccgf are always functions. The quantities Lambda and Sigma can either be functions or matrices. For example, in endowment economies like Wachter (2013), Lambda is the zero matrix since there is no endogenous risk. In other applications, Sigma may not be state-dependent and thus a constant matrix. The last two quantities Gamma_5 and Gamma_6 are always matrices.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"In addition, you need to define initial guesses for the coefficients z, y, Ψ and specify the number of exogenous shocks Nε. The initial guesses can be undefined if you don't want to use actual numbers yet, but you will eventually need to provide guesses in order for the nonlinear solvers to work in the numerical algorithms.","category":"page"},{"location":"example/#Instantiate-the-object-1","page":"Example","title":"Instantiate the object","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"Once you have the required quantities, simply call","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"ral = RiskAdjustedLinearization(μ, Λ, Σ, ξ, Γ₅, Γ₆, ccgf, z, y, Ψ, Nε)","category":"page"},{"location":"example/#Example-1","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The following code presents a function that defines the desired functions and matrices, given the parameters for the model in Wachter (2013), and returns a RiskAdjustedLinearization object. The code is from this script examples/wachter_disaster_risk/wachter.jl, which has examples for both in-place and out-of-place functions.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"function inplace_wachter_disaster_risk(m::WachterDisasterRisk{T}) where {T <: Real}\n    @unpack μₐ, σₐ, ν, δ, ρₚ, pp, ϕₚ, ρ, γ, β = m\n\n    @assert ρ != 1. # Forcing ρ to be non-unit for this example\n\n    S  = OrderedDict{Symbol, Int}(:p => 1,  :εc => 2, :εξ => 3) # State variables\n    J  = OrderedDict{Symbol, Int}(:vc => 1, :xc => 2, :rf => 3) # Jump variables\n    SH = OrderedDict{Symbol, Int}(:εₚ => 1, :εc => 2, :εξ => 3) # Exogenous shocks\n    Nz = length(S)\n    Ny = length(J)\n    Nε = length(SH)\n\n    function μ(F, z, y)\n        F_type    = eltype(F)\n        F[S[:p]]  = (1 - ρₚ) * pp + ρₚ * z[S[:p]]\n        F[S[:εc]] = zero(F_type)\n        F[S[:εξ]] = zero(F_type)\n    end\n\n    function ξ(F, z, y)\n        F[J[:vc]] = log(β) - γ * μₐ + γ * ν * z[S[:p]] - (ρ - γ) * y[J[:xc]] + y[J[:rf]]\n        F[J[:xc]] = log(1. - β + β * exp((1. - ρ) * y[J[:xc]])) - (1. - ρ) * y[J[:vc]]\n        F[J[:rf]] = (1. - γ) * (μₐ - ν * z[S[:p]] - y[J[:xc]])\n    end\n\n    Λ = zeros(T, Nz, Ny)\n\n    function Σ(F, z)\n        F_type = eltype(F)\n        F[SH[:εₚ], SH[:εₚ]] = sqrt(z[S[:p]]) * ϕₚ * σₐ\n        F[SH[:εc], SH[:εc]] = one(F_type)\n        F[SH[:εξ], SH[:εξ]] = one(F_type)\n    end\n\n    function ccgf(F, α, z)\n        F .= .5 .* α[:, 1].^2 + .5 * α[:, 2].^2 + (exp.(α[:, 3] + α[:, 3].^2 .* δ^2 ./ 2.) .- 1. - α[:, 3]) * z[S[:p]]\n    end\n\n    Γ₅ = zeros(T, Ny, Nz)\n    Γ₅[J[:vc], S[:εc]] = (-γ * σₐ)\n    Γ₅[J[:vc], S[:εξ]] = (γ * ν)\n    Γ₅[J[:rf], S[:εc]] = (1. - γ) * σₐ\n    Γ₅[J[:rf], S[:εξ]] = -(1. - γ) * ν\n\n    Γ₆ = zeros(T, Ny, Ny)\n    Γ₆[J[:vc], J[:vc]] = (ρ - γ)\n    Γ₆[J[:rf], J[:vc]] = (1. - γ)\n\n    z = [pp, 0., 0.]\n    xc_sss = log((1. - β) / (exp((1. - ρ) * (ν * pp - μₐ)) - β)) / (1. - ρ)\n    vc_sss = xc_sss + ν * pp - μₐ\n    y = [vc_sss, xc_sss, -log(β) + γ * (μₐ - ν * pp) - (ρ - γ) * (vc_sss - xc_sss)]\n    Ψ = zeros(T, Ny, Nz)\n    return RiskAdjustedLinearization(μ, Λ, Σ, ξ, Γ₅, Γ₆, ccgf, z, y, Ψ, Nε)\nend","category":"page"},{"location":"example/#Solve-using-a-Newton-type-Numerical-Algorithm-1","page":"Example","title":"Solve using a Newton-type Numerical Algorithm","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"To solve the model using the relaxation algorithm, just call","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"solve!(ral; algorithm = :relaxation)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"This form of solve! uses the coefficients in ral as initial guesses. To specify other initial guesses, call","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"solve!(ral, z0, y0, Ψ0; algorithm = :relaxation)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"If you don't have a guess for Psi, then you can just provide guesses for z and y:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"solve!(ral, z0, y0; algorithm = :relaxation)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"In this case, we calculate the deterministic steady state first using z and y; back out the implied Psi; and then proceed with the relaxation algorithm using the deterministic steady state as the initial guess.","category":"page"}]
}
