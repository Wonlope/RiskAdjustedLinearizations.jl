<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Algorithms · RiskAdjustedLinearizations.jl</title><link rel="canonical" href="https://invenia.github.io/PkgTemplates.jl/numerical_algorithms/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RiskAdjustedLinearizations.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../risk_adjusted_linearization/">Risk-Adjusted Linearizations</a></li><li class="is-active"><a class="tocitem" href>Numerical Algorithms</a><ul class="internal"><li><a class="tocitem" href="#solve!-1"><span><code>solve!</code></span></a></li><li><a class="tocitem" href="#relaxation-1"><span>Relaxation</span></a></li><li><a class="tocitem" href="#homotopy-1"><span>Homotopy Continuation</span></a></li><li><a class="tocitem" href="#blanchard-kahn-1"><span>Blanchard-Kahn Conditions</span></a></li><li><a class="tocitem" href="#Docstrings-1"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../example/">Example</a></li><li><a class="tocitem" href="../tips/">Tips</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chenwilliam77/RiskAdjustedLinearizations.jl/blob/master/docs/src/numerical_algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="numerical-algorithms-1"><a class="docs-heading-anchor" href="#numerical-algorithms-1">Numerical Algorithms</a><a class="docs-heading-anchor-permalink" href="#numerical-algorithms-1" title="Permalink"></a></h1><p>n To calculate the risk-adjusted linearization, we need to solve a system of nonlinear equations. These equations are generally solvable using Newton-type methods. The package currently has two available algorithms, <a href="#relaxation-1">relaxation</a> and <a href="#homotopy-1">homotopy continuation</a></p><h2 id="solve!-1"><a class="docs-heading-anchor" href="#solve!-1"><code>solve!</code></a><a class="docs-heading-anchor-permalink" href="#solve!-1" title="Permalink"></a></h2><p>The primary interface for calculating a risk-adjusted linearization once a <code>RiskAdjustedLinearization</code> object is created is the function <code>solve!</code>. The user selects the desired numerical algorithm through <code>algorithm</code> keyword of <code>solve!</code>.</p><p>All of the available algorithms need to solve a system of nonlinear equations. We use <code>nlsolve</code> for this purpose, and all keyword arguments for <code>nlsolve</code> can be passed as keyword arguments to <code>solve!</code>, e.g. <code>autodiff</code> and <code>ftol</code>.</p><pre><code class="language-">RiskAdjustedLinearizations.solve!</code></pre><h2 id="relaxation-1"><a class="docs-heading-anchor" href="#relaxation-1">Relaxation</a><a class="docs-heading-anchor-permalink" href="#relaxation-1" title="Permalink"></a></h2><p>The first and default numerical algorithm is a relaxation algorithm. The key problem in solving the equations characterizing <span>$(z, y, \Psi)$</span> is that it is difficult to jointly solve the nonlinear matrix equation for <span>$\Psi$</span> along with the steady-state equations for <span>$z$</span> and <span>$y$</span> due to the presence of the entropy term. The relaxation algorithm splits the solution of these equations into two steps, which allows us to calculate guesses of <span>$\Psi$</span> using linear algebra. It is in this sense that this iterative algorithm is a relaxation algorithm.</p><p>The system of equations characterizing the coefficients <span>$(z, y, \Psi)$</span> are solved iteratively in two separate steps. Given previous guesses <span>$(z_{n - 1}, y_{n - 1}, \Psi_{n - 1})$</span>, we calculate <span>$(z_n, y_n)$</span> such that</p><p>``math \begin{aligned} 0 &amp; = \mu(z<em>n, y</em>n) - z<em>n,\
0 &amp; = \xi(z</em>n, y<em>n) + \Gamma</em>5 z<em>n + \Gamma</em>6 y<em>n + \mathscr{V}(z</em>{n - 1}),\
\end{aligned} ``</p><p>is satisfied. In other words, we hold the entropy term constant and update <span>$(z_n, y_n)$</span> in the remaining terms. The coefficients are solved efficiently through <code>nlsolve</code> with <span>$(z_{n - 1}, y_{n - 1})$</span> as initial guesses.</p><p>Then we compute <span>$\Psi_n$</span> by solving</p><p><span>$math \begin{aligned} 0 &amp; = \Gamma_3 + \Gamma_4 \Psi_n + (\Gamma_5 + \Gamma_6 \Psi_n)(\Gamma_1 + \Gamma_2 \Psi_n) + J\mathscr{V}(z_{n - 1}). \end{aligned}$</span></p><p>with a <a href="https://en.wikipedia.org/wiki/Schur_decomposition#Generalized_Schur_decomposition">Generalized Schur decomposition</a> (also known as QZ decomposition). Notice that we also hold the Jacobian of the entropy constant. Only after we have a new round of <span>$(z_n, y_n, \Psi_n)$</span> do we update the entropy-related terms.</p><p>Convergence is achieved once <span>$(z_n, y_n, \Psi_n)$</span> are sufficiently close under some norm. By default, we use the <span>$L^\infty$</span> norm (maximum absolute error).</p><h2 id="homotopy-1"><a class="docs-heading-anchor" href="#homotopy-1">Homotopy Continuation</a><a class="docs-heading-anchor-permalink" href="#homotopy-1" title="Permalink"></a></h2><p>When the deterministic steady state exists, it is typically an easy problem to solve numerically. We can therefore use the equations characterizing the deterministic steady state for a <a href="https://en.wikipedia.org/wiki/Numerical_algebraic_geometry">homotopy continuation method</a>. Let <span>$q$</span> be the embedding parameter. Then the homotopy continuation method iteratively solves</p><p>``math \begin{aligned} 0 &amp; = \mu(z, y) - z,\
0 &amp; = \xi(z, y) + \Gamma<em>5 z + \Gamma</em>6 y + q \mathscr{V}(z),\
0 &amp; = \Gamma<em>3 + \Gamma</em>4 \Psi + (\Gamma<em>5 + \Gamma</em>6 \Psi)(\Gamma<em>1 + \Gamma</em>2 \Psi) + q J\mathscr{V}(z) \end{aligned} ``</p><p>for the coefficients <span>$(z_q, y_q, \Psi_q)$</span> by increasing <span>$q$</span> from 0 to 1.</p><h2 id="blanchard-kahn-1"><a class="docs-heading-anchor" href="#blanchard-kahn-1">Blanchard-Kahn Conditions</a><a class="docs-heading-anchor-permalink" href="#blanchard-kahn-1" title="Permalink"></a></h2><p>At the end of <code>solve!</code>, we check the stochastic steady state found is locally unique and saddle-path stable by checking what are known as the Blanchard-Kahn conditions. Standard references for computational macroeconomics explain what these conditions are, so we defer to them (e.g. <a href="http://dept.ku.edu/~empirics/Emp-Coffee/blanchard-kahn_eca80.pdf">Blanchard-Kahn (1980)</a>, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.335.8685&amp;rep=rep1&amp;type=pdf">Klein (2000)</a>, and <a href="https://link.springer.com/article/10.1023/A:1020517101123">Sims (2002)</a>). For the stochastic steady state, these conditions are essentially identical to the conditions for the deterministic steady state, but the Jacobian of the expectational equations to <span>$z_t$</span> also includes the Jacobian of the entropy. In the deterministic steady state, the entropy is zero, hence the Jacobian of the entropy is zero. In the stochastic steady state, the entropy is no longer zero and varies with <span>$z_t$</span>, hence the Jacobian of the expectational equations to <span>$z_t$</span> depends on entropy.</p><h2 id="Docstrings-1"><a class="docs-heading-anchor" href="#Docstrings-1">Docstrings</a><a class="docs-heading-anchor-permalink" href="#Docstrings-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RiskAdjustedLinearizations.relaxation!" href="#RiskAdjustedLinearizations.relaxation!"><code>RiskAdjustedLinearizations.relaxation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function relaxation!(m, xₙ₋₁, Ψₙ₋₁; tol = 1e-10, max_iters = 1000, damping = .5, pnorm = Inf,
                    schur_fnct::Function = schur!, verbose = :none, kwargs...)</code></pre><p>solves for the coefficients <span>$(z, y, \Psi)$</span> of a risk-adjusted linearization by the following relaxation algorithm:</p><ol><li>Initialize guesses for <span>$(z, y, \Psi)$</span></li><li>Do until convergence  a) Solve for <span>$(z, y)$</span> using the expectational and state transition equations and fixing <span>$\Psi$</span>.  b) Use a QZ decomposition to solve for <span>$\Psi$</span> while fixing <span>$(z, y)$</span>.</li></ol><p><strong>Types:</strong></p><ul><li><code>S1 &lt;: Number</code></li><li><code>S2 &lt;: Real</code></li><li><code>S3 &lt;: Real</code></li></ul><p><strong>Inputs</strong></p><ul><li><code>m::RiskAdjustedLinearization</code>: object holding functions needed to calculate   the risk-adjusted linearization</li><li><code>xₙ₋₁::AbstractVector{S1}</code>: initial guess for <span>$(z, y)$</span></li><li><code>Ψₙ₋₁::AbstractVector{S1}</code>: initial guess for <span>$\Psi$</span></li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::S2</code>: convergence tolerance of residual norm for relaxation algorithm</li><li><code>max_iters::Int</code>: maximumm number of iterations</li><li><code>damping::S2</code>: guesses are updated as the weighted average   <code>xₙ = damping * proposal + (1 - damping) * xₙ₋₁</code>.</li><li><code>pnorm::S3</code>: norm for residual tolerance</li><li><code>schur_fnct::Function</code>: function for calculating the Schur factorization during QZ decomposition</li><li><code>verbose::Symbol</code>: verbosity of information printed out during solution.   a) <code>:low</code> -&gt; statement when homotopy continuation succeeds   b) <code>:high</code> -&gt; statement when homotopy continuation succeeds and for each successful iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chenwilliam77/RiskAdjustedLinearizations.jl/blob/be76399f6585faa1d3e2f942442f3e43f1fd4964/src/numerical_algorithms/relaxation.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RiskAdjustedLinearizations.homotopy!" href="#RiskAdjustedLinearizations.homotopy!"><code>RiskAdjustedLinearizations.homotopy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">homotopy!(m, xₙ₋₁; step = .1, verbose = :none, kwargs...)</code></pre><p>solves the system of equations characterizing a risk-adjusted linearization by a homotopy method with embedding parameter <span>$q$</span>, which steps from 0 to 1, with <span>$q = 1$</span> obtaining the true solution.</p><p>Currently, the only algorithm for choosing <span>$q$</span> is a simple uniform step search. Given a step size <span>$\Delta$</span><code>, we solve the homotopy starting from</code><code>q = \Delta</code><code>and increase</code><code>q</code><code>by</code><code>\Delta</code><code>until</code><code>q</code><code>reaches 1 or passes 1 (in which case, we force</code><code>q = 1</code>`).</p><p><strong>Types:</strong></p><ul><li><code>S1 &lt;: Number</code></li></ul><p><strong>Inputs</strong></p><ul><li><code>m::RiskAdjustedLinearization</code>: object holding functions needed to calculate   the risk-adjusted linearization</li><li><code>xₙ₋₁::AbstractVector{S1}</code>: initial guess for <span>$(z, y, \Psi)$</span></li></ul><p><strong>Keywords</strong></p><ul><li><code>step::Float64</code>: size of the uniform step from <code>step</code> to 1.</li><li><code>verbose::Symbol</code>: verbosity of information printed out during solution.   a) <code>:low</code> -&gt; statement when homotopy continuation succeeds   b) <code>:high</code> -&gt; statement when homotopy continuation succeeds and for each successful iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chenwilliam77/RiskAdjustedLinearizations.jl/blob/be76399f6585faa1d3e2f942442f3e43f1fd4964/src/numerical_algorithms/homotopy.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RiskAdjustedLinearizations.blanchard_kahn" href="#RiskAdjustedLinearizations.blanchard_kahn"><code>RiskAdjustedLinearizations.blanchard_kahn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blanchard_kahn(m::RiskAdjustedLinearization; deterministic::Bool = false, verbose::Symbol = :high)</code></pre><p>checks the Blanchard-Kahn conditions for whether a first-order perturbation is saddle-path stable or not.</p><p>If <code>verbose</code> is <code>:low</code> or <code>:high</code>, a print statement will be shown if the Blanchard-Kahn conditions are satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chenwilliam77/RiskAdjustedLinearizations.jl/blob/be76399f6585faa1d3e2f942442f3e43f1fd4964/src/numerical_algorithms/blanchard_kahn.jl#L1-L9">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../risk_adjusted_linearization/">« Risk-Adjusted Linearizations</a><a class="docs-footer-nextpage" href="../example/">Example »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 12 September 2020 17:16">Saturday 12 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
