using ForwardDiff

"""
    RiskAdjustedLinearization(Œº, Œõ, Œ£, Œæ, Œì‚ÇÖ, Œì‚ÇÜ, ùí±, Nz, Ny, NŒµ)

Creates a first-order perturbation around the stochastic steady state ``(z, y)`` of a discrete-time dynamic model.

(TODO: Move more of the formality to documentation, and make this shorter and concise, w/out explanation of matrix equations)
The affine approximation of the model is
``math
\\begin{aligned}
    \\mathbb{E}[z_{t + 1}] & = \\mu(z, y) + \\Gamma_1(z_t - z) + \\Gamma_2(y_t - y)\\\\
    0                      & = \\xi(z, y) + \\Gamma_3(z_t - z) + \\Gamma_4(y_t - y) + \\Gamma_5 \\mathbb{E}_t z_{t + 1} + \\Gamma_6 \\mathbb{E}_t y_{t + 1} + \\mathscr{V}(z) + J\\mathscr{V}(z)(z_t  - z),
\\end{aligned}
``

where ``\\Gamma_1, \\Gamma_2`` are the Jacobians of ``\\mu`` with respect to ``z_t`` and ``y_t``, respectively;
``\\Gamma_3, \\Gamma_4`` are the Jacobians of ``\\xi`` with respect to ``z_t`` and ``y_t``, respectively;
``\\Gamma_5, \\Gamma_6`` are constant matrices; ``\\mathscr{V}(z)`` is the model's entropy;
``J\\mathscr{V}(z)`` is the Jacobian of the entropy;

and the state variables ``z_t`` and jump variables ``y_t`` follow
``math
\\begin{aligned}
    z_{t + 1} & = z + \\Gamma_1(z_t - z) + \\Gamma_2(y_t - y) + (I_{n_z} - \\Lambda(z_t) \\Psi)^{-1}\\Sigma(z_t)\\varepsilon_{t + 1},\\\\
    y_t       & = y + \\Psi(z_t - z)
\\end{aligned}
``

The unknowns ``(z, y, \\Psi)`` solve the system of equations
``math
\\begin{aligned}
0 & = \\mu(z, y) - z,\\\\
0 & = \\xi(z, y) + \\Gamma_5 z + \\Gamma_6 y + \\mathscr{V}(z),\\\\
0 & = \\Gamma_3 + \\Gamma_4 \\Psi + (\\Gamma_5 + \\Gamma_6 \\Psi)(\\Gamma_1 + \\Gamma_2 \\Psi) + J\\mathscr{V}(z).
\\end{aligned}
``
(TODO: Move the nonlinear model statement to documentation)
The true nonlinear equations defining model are assumed to take the form

``math
\\begin{aligned}
    z_{t + 1} & = \\mu(z_t, y_t) + \\Lambda(z_t)(y_{t + 1} - \\mathbb{E}_t y_{t + 1}) + \\Sigma(z_t) \\varepsilon_{t + 1},\\\\
    0 & = \\log\\mathbb{E}_t[\\exp(\\xi(z_t, y_t) + \\Gamma_5 z_{t + 1} + \\Gamma_6 y_{t + 1})].
\\end{aligned}
``

The vectors ``z_t\\in \\mathbb{R}^{n_z}`` and ``y_t \\in \\mathbb{R}^{n_y}`` are the state and jump variables, respectively.
The first vector equation comprise the model's expectational equations, which are typically
the first-order conditions for the jump variables from agents' optimization problem.
The second vector equation comprise the transition equations of the state variables. The exogenous shocks
``\\varepsilon\\in\\mathbb{R}^{n_\\varepsilon}`` form a martingale difference sequence whose distribution
is described by the differentiable, conditional cumulant generating function (ccgf)

``math
\\begin{aligned}
\\kappa[\\alpha(z_t) \\mid z_t] = \\log\\mathbb{E}_t[\\exp(\\alpha(z_t)' \\varepsilon_{t + 1})],\\quad \text{ for any differentiable map }\\alpha::\\mathbb{R}^{n_z}\\rightarrow\\mathbb{R}^{n_\\varepsilon}.
\\end{aligned}
``

The functions
``math
\\begin{aligned}
\\xi:\\mathbb{R}^{2n_y + 2n_z}\\rightarrow \\mathbb{R}^{n_y},& \\quad \\mu:\\mathbb{R}^{n_y + n_z}\\rightarrow \\mathbb{R}^{n_z},\\\\
\\Lambda::\\mathbb{R}^{n_z} \\rightarrow \\mathbb{R}^{n_z \\times n_y}, & \\quad \\Sigma::\\mathbb{R}^{n_z}\\rightarrow \\mathbb{R}^{n_z\\times n_\\varepsilon}
\\end{aligned}
are differentiable. The first two functions characterize the effects of time ``t`` variables on the expectational and
state transition equations. The function ``\\Lambda`` characterizes heteroskedastic endogenous risk that depends on
innovations in jump variables while the function ``\\Sigma`` characterizes exogenous risk.

Refer to Lopz et al. (2018) "Risk-Adjusted Linearizations of Dynamic Equilibrium Models" for details.
"""
mutable struct RiskAdjustedLinearization{M <: Function, L, S,
                                         X <: Function, V <: Function,
                                         Mz <: Function, My <: Function, Xz <: Function, Xy <: Function, J <: Function,
                                         VC <: AbstractVector{<: Number}, JC <: AbstractMatrix{<: Number},
                                         C1 <: AbstractVector{<: Number}, C2 <: AbstractMatrix{<: Number}}
    Œº::M         # Functions
    Œõ::L         # no type assertion for L b/c it can be Function or Matrix of zeros
    Œ£::S         # no type assertion for S b/c it can be Function or constant Matrix
    Œæ::X
    ùí±::V
    Œºz::Mz
    Œºy::My
    Œæz::Xz
    Œæy::Xy
    Jùí±::J
    Œº_sss::VC    # Stochastic steady state values, for caching
    Œæ_sss::VC
    ùí±_sss::VC
    Œì‚ÇÅ::JC       # Jacobians, for caching
    Œì‚ÇÇ::JC
    Œì‚ÇÉ::JC
    Œì‚ÇÑ::JC
    Œì‚ÇÖ::JC
    Œì‚ÇÜ::JC
    JV::JC
    z::C1        # Coefficients
    y::C1
    Œ®::C2
    Nz::Int      # Dimensions
    Ny::Int
    NŒµ::Int
end

#=
TODO: Finish this once the final struct is completed
# A series of lower level constructors
function RiskAdjustedLinearization(Œº::M, Œõ::L, Œ£::S, Œæ::X, ùí±::V, Œºz::Mz, Œºy::My, Œæz::Xz, Œæy::Xy, Jùí±::J,
                                   Œº_sss::AbstractVector{T}, Œæ_sss::AbstractVector{T}, ùí±_sss::AbstractVector{T},
                                   Œì‚ÇÅ::AbstractMatrix{T}, Œì‚ÇÇ::AbstractMatrix{T}, Œì‚ÇÉ::AbstractMatrix{T}
                                   Œì‚ÇÑ::AbstractMatrix{T}, Œì‚ÇÖ::AbstractMatrix{T}, Œì‚ÇÜ::AbstractMatrix{T},
                                   JV::AbstractMatrix{T}, z::AbstractVector{T}, y::AbstractVector{T}, Œ®::AbstractMatrix{T},
                                   NŒµ::Int = -1) where {T <: Number, M <: Function, L,
                                                        S, X <: Function, V <: Function,
                                                        Mz <: Function, My <: Function, Xz <: Function,
                                                        Xy <: Function, J <: Function}

    Nz = length(z)
    Ny = length(y)
    if NŒµ < 0
        NŒµ = size(Œ£(z), 2)
    end

    return RiskAdjustedLinearization{T, M, L, S, X, V, J}(Œº, Œõ, Œ£, Œæ, ùí±, Jùí±, Œº_sss, Œæ_sss, ùí±_sss,
                                                          Œì‚ÇÅ, Œì‚ÇÇ, Œì‚ÇÉ, Œì‚ÇÑ, Œì‚ÇÖ, Œì‚ÇÜ,
                                                          JV, z, y, Œ®, Nz, Ny, NŒµ)
end


function RiskAdjustedLinearization(Œº::M, Œõ::L, Œ£::S, Œæ::X, ùí±::V, Œºz::Mz, Œºy::My, Œæz::Xz, Œæy::Xy, Jùí±::J,
                                   Œì‚ÇÅ::AbstractMatrix{T}, Œì‚ÇÇ::AbstractMatrix{T}, Œì‚ÇÉ::AbstractMatrix{T}
                                   Œì‚ÇÑ::AbstractMatrix{T}, Œì‚ÇÖ::AbstractMatrix{T}, Œì‚ÇÜ::AbstractMatrix{T},
                                   JV::AbstractMatrix{T}, z::AbstractVector{T}, y::AbstractVector{T}, Œ®::AbstractMatrix{T},
                                   NŒµ::Int = -1) where {T <: Number, M <: Function, L,
                                                        S, X <: Function, V <: Function,
                                                        Mz <: Function, My <: Function, Xz <: Function,
                                                        Xy <: Function, J <: Function}
    Nz = length(z)
    Ny = length(y)
    if NŒµ < 0
        NŒµ = size(Œ£(z), 2)
    end

    # Cache stochastic steady state vectors
    Œº_sss, Œæ_sss, ùí±_sss = _cache_sss_vectors(z, y)

    return RiskAdjustedLinearization{T, M, L, S, X, V, J}(Œº, Œõ, Œ£, Œæ, ùí±, Jùí±, Œº_sss, Œæ_sss, ùí±_sss,
                                                          Œì‚ÇÅ, Œì‚ÇÇ, Œì‚ÇÉ, Œì‚ÇÑ, Œì‚ÇÖ, Œì‚ÇÜ,
                                                          JV, z, y, Œ®, Nz, Ny, NŒµ)
end

function RiskAdjustedLinearization(Œº::M, Œõ::L, Œ£::S, Œæ::X, ùí±::V, Œºz::Mz, Œºy::My, Œæz::Xz, Œæy::Xy, Jùí±::J,
                                   z::AbstractVector{T}, y::AbstractVector{T}, Œ®::AbstractMatrix{T},
                                   NŒµ::Int = -1) where {T <: Number, M <: Function, L,
                                                        S, X <: Function, V <: Function,
                                                        Mz <: Function, My <: Function, Xz <: Function,
                                                        Xy <: Function, J <: Function}
    # Get dimensions
    Nz = length(z)
    Ny = length(y)
    if NŒµ < 0
        NŒµ = size(Œ£(z), 2)
    end

    # Cache stochastic steady state vectors
    Œº_sss, Œæ_sss, ùí±_sss = _cache_sss_vectors(z, y)

    # Cache stochastic steady state Jacobians
    Œì‚ÇÅ, Œì‚ÇÇ, Œì‚ÇÉ, Œì‚ÇÑ, Œì‚ÇÖ, Œì‚ÇÜ, JV = _cache_jacobians(Œ®, Nz, Ny)

    return RiskAdjustedLinearization{T, M, L, S, X, V, J}(Œº, Œõ, Œ£, Œæ, ùí±, Jùí±, Œº_sss, Œæ_sss, ùí±_sss,
                                                          Œì‚ÇÅ, Œì‚ÇÇ, Œì‚ÇÉ, Œì‚ÇÑ, Œì‚ÇÖ, Œì‚ÇÜ,
                                                          JV, z, y, Œ®, Nz, Ny, NŒµ)
end
=#

# Constructor that uses ForwardDiff to calculate Jacobian functions
# NOTE THAT here we pass in the ccgf, rather than ùí±
function RiskAdjustedLinearization(Œº::M, Œõ::L, Œ£::S, Œæ::X, ccgf::CF,
                                   z::AbstractVector{T}, y::AbstractVector{T}, Œ®::AbstractMatrix{T},
                                   NŒµ::Int = -1) where {T <: Number, M <: Function, L,
                                                        S, X <: Function, CF <: Function}
    # Get dimensions
    Nz = length(z)
    Ny = length(y)
    if NŒµ < 0
        NŒµ = size(Œ£(z), 2)
    end

    # Cache stochastic steady state vectors
    Œº_sss, Œæ_sss, ùí±_sss = _cache_sss_vectors(z, y)

    # Cache stochastic steady state Jacobians
    Œì‚ÇÅ, Œì‚ÇÇ, Œì‚ÇÉ, Œì‚ÇÑ, Œì‚ÇÖ, Œì‚ÇÜ, JV = _cache_jacobians(Œ®, Nz, Ny)

    # Use cached Jacobians to create Jacobian functions for Œº, Œæ
    if applicable(Œº, z, y) # Check if Œº is in place or not
        Œºz = (F, z, y) -> ForwardDiff.jacobian!(F, x -> Œº(x, y), z) # not in place
        Œºy = (F, z, y) -> ForwardDiff.jacobian!(F, x -> Œº(z, x), y)
    else # in place
        Œºz = (F, z, y, Œº_sss) -> ForwardDiff.jacobian!(F, (G, x) -> Œº(G, x, y), Œº_sss, z)
        Œºy = (F, z, y, Œº_sss) -> ForwardDiff.jacobian!(F, (G, x) -> Œº(G, z, x), Œº_sss, y)
    end

    if applicable(Œæ, z, y) # Check if Œæ is in place or not
        Œæz = (F, z, y) -> ForwardDiff.jacobian!(F, x -> Œæ(x, y), z) # not in place
        Œæy = (F, z, y) -> ForwardDiff.jacobian!(F, x -> Œæ(z, x), y)
    else # in place
        Œæz = (F, z, y, Œæ_sss) -> ForwardDiff.jacobian!(F, (G, x) -> Œæ(G, x, y), Œæ_sss, z)
        Œæy = (F, z, y, Œæ_sss) -> ForwardDiff.jacobian!(F, (G, x) -> Œæ(G, z, x), Œæ_sss, y)
    end

    # Create ùí± and its Jacobian Jùí±
    if applicable(ccgf, z) # Check if ccgf is in place or not
        ùí± = function _ùí±(F, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ)
            F .= ccgf((Œì‚ÇÖ + Œì‚ÇÜ * Œ®) * ((I - Œõ(z) * Œ®) \ Œ£(z)), z)
        end
    else # in place
        ùí± = (F, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ) -> ccgf(F, (Œì‚ÇÖ + Œì‚ÇÜ * Œ®) * ((I - Œõ(z) * Œ®) \ Œ£(z)), z)
    end
    Jùí± = function _Jùí±(F, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ, ùí±_sss)
        ForwardDiff.jacobian!(F, (G, x) -> ùí±(G, x, Œ®, Œì‚ÇÖ, Œì‚ÇÜ), ùí±_sss, z)
    end

    _check_inputs(z, y, Œ®, Œì‚ÇÖ, Œì‚ÇÜ, Œº_sss, Œæ_sss, ùí±_sss, Œº, Œõ, Œ£, Œæ, ùí±, Œºz, Œºy, Œæz, Œæy, Jùí±)

    return RiskAdjustedLinearization(Œº, Œõ, Œ£, Œæ, ùí±, Œºz, Œºy, Œæz, Œæy, Jùí±, Œº_sss, Œæ_sss, ùí±_sss,
                                     Œì‚ÇÅ, Œì‚ÇÇ, Œì‚ÇÉ, Œì‚ÇÑ, Œì‚ÇÖ, Œì‚ÇÜ, JV, z, y, Œ®, Nz, Ny, NŒµ)
end

# Create a function that takes in a ccgf and creates the associated entropy function, given the right inputs

# Rewrite the solution code to operate on jacobians, etc.

function _cache_jacobians(Œ®::AbstractMatrix{T}, Nz::Int, Ny::Int) where {T <: Number}

    Œ®type = typeof(Œ®)
    Œì‚ÇÅ = convert(Œ®type, Matrix{T}(undef, Nz, Nz))
    Œì‚ÇÇ = convert(Œ®type, Matrix{T}(undef, Nz, Ny))
    Œì‚ÇÉ = similar(Œ®)
    Œì‚ÇÑ = convert(Œ®type, Matrix{T}(undef, Ny, Ny))
    Œì‚ÇÖ = similar(Œ®)
    Œì‚ÇÜ = similar(Œì‚ÇÑ)
    JV = similar(Œ®)

    return Œì‚ÇÅ, Œì‚ÇÇ, Œì‚ÇÉ, Œì‚ÇÑ, Œì‚ÇÖ, Œì‚ÇÜ, JV
end

function _cache_sss_vectors(z::AbstractVector{T}, y::AbstractVector{T}) where {T <: Number}

    Œº_sss = similar(z)
    Œæ_sss = similar(y)
    ùí±_sss = similar(y)

   return Œº_sss, Œæ_sss, ùí±_sss
end

function _check_inputs(z::C1, y::C1, Œ®::C2, Œì‚ÇÖ::JC, Œì‚ÇÜ::JC,
                       Œº_sss::VC, Œæ_sss::VC, ùí±_sss::VC,
                       Œº::M, Œõ::L, Œ£::S, Œæ::X, ùí±::V, Œºz::Mz,
                       Œºy::My, Œæz::Xz, Œæy::Xy, Jùí±::J)  where {C1 <: AbstractVector{<: Number}, C2 <: AbstractMatrix{<: Number},
                                                              VC <: AbstractVector{<: Number}, JC <: AbstractMatrix{<: Number},
                                                              M <: Function, L, S,
                                                              X <: Function, V <: Function, Mz <: Function, My <: Function,
                                                              Xz <: Function, Xy <: Function, J <: Function}

    @assert applicable(Œº, z, y) ||
        applicable(Œº, z, z, y) "The function Œº must take either the form " *
        "Œº(z, y) or the in-place equivalent Œº(F, z, y)"

    @assert applicable(Œæ, z, y) ||
        applicable(Œæ, z, z, y) "The function Œº must take either the form " *
        "Œæ(z, y) or the in-place equivalent Œæ(F, z, y)"

     @assert applicable(Œõ, z) ||
         applicable(Œõ, Œ®, z) "The function Œõ must take either the form Œõ(z) or the in-place equivalent Œõ(F, z)"

     @assert applicable(Œ£, z) ||
         applicable(Œ£, Œ®, z) "The function Œõ must take either the form Œ£(z) or the in-place equivalent Œ£(F, z)"

    @assert applicable(ùí±, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ) ||
        applicable(ùí±, y, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ) "The function ùí± must take either the form " *
        "ùí±(z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ) or the in-place equivalent ùí±(F, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ)"

    @assert applicable(Œºz, z, y) ||
        applicable(Œºz, Œ®, z, y, Œº_sss) "The function Œºz must take either the form " *
        "Œºz(z, y) or the in-place equivalent Œºz(F, z, y, Œº_sss)"

    @assert applicable(Œºy, z, y) ||
        applicable(Œºy, Œ®, z, y, Œº_sss) "The function Œºy must take either the form " *
        "Œºy(z, y) or the in-place equivalent Œºy(F, z, y, Œº_sss)"

    @assert applicable(Œæz, z, y) ||
        applicable(Œæz, Œ®, z, y, Œæ_sss) "The function Œæz must take either the form " *
        "Œæz(z, y) or the in-place equivalent Œæz(F, z, y, Œæ_sss)"

    @assert applicable(Œæy, z, y) ||
        applicable(Œæy, Œ®, z, y, Œæ_sss) "The function Œæy must take either the form " *
        "Œæy(z, y) or the in-place equivalent Œæy(F, z, y, Œæ_sss)"

    @assert applicable(Jùí±, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ) ||
        applicable(Jùí±, Œ®, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ, ùí±_sss) "The function Jùí± must take either the form " *
        "Jùí±(z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ) or the in-place equivalent Jùí±(F, z, Œ®, Œì‚ÇÖ, Œì‚ÇÜ, ùí±_sss)"
end
